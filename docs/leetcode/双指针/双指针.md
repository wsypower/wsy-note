# 双指针

## 双指针种类


| 双指针种类 | 对应题 | 关键词 |
| - | - | - |
| 快慢指针 |   |   |
| 对撞指针 | 对称<br /> |   |

## 关键词

* 对称

## 简介

二分查找也称**折半查找（Binary Search）**，它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列

::: tip 注意

1. 折半查找要求线性表必须采用**顺序存储结构**
2. 而且表中元素按关键字**有序排列**

:::

::: tip 关键词

* 顺序结构

:::

## 思路分析

* 首先确定该数组的中间的下标mid = (left + right) / 2
* 然后让需要查找的数 findVal 和 arr[mid] 比较

  * findVal > arr[mid] ,  说明你要查找的数在mid 的右边, 因此需要递归的向右查找
  * findVal < arr[mid], 说明你要查找的数在mid 的左边, 因此需要递归的向左查找
  * findVal == arr[mid] 说明找到，就返回
* 什么时候我们需要结束递归.

## 公式

```js
const formula = (s) => {
  // 缓存对撞指针长度
  const len = s.length;
  // 左指针
  let i = 0;
  // 右指针
  let j = len - 1;
  while (i < j) {
    if (/符合条件/) {
      [s[i], s[j]] = [s[j], s[i]];
      i++;
      j--;
    }
    if (/其他条件/) {
      i++;
    }
    if (/其他条件/) {
      j--;
    }
  }
  return s;
};

```

### 对撞题目练习

---


#### [验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

> 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

::: tip 说明

本题中，我们将空字符串定义为有效的回文串。

:::

**示例 1:**

```js
输入: "A man, a plan, a canal: Panama"
输出: true
```

**示例 2:**

```js
输入: "race a car"
输出: false
```

**题解:**

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
  const replaces = s.replace(/[\W_]*/g, "").toLowerCase();
  if (!replaces.length) {
    return true;
  }
  let i = 0;
  let j = replaces.length - 1;
  while (i < j && replaces[i] === replaces[j]) {
    i++;
    j--;
  }
  return i >= j;
};
```




#### [反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)

编写一个函数，以字符串作为输入，反转该字符串中的元音字母。

**示例 1：**

```js
输入："hello"
输出："holle"
```

**示例 2：**

```js
输入："leetcode"
输出："leotcede"
```

**提示：**

* 元音字母不包含字母 "y" 。

```js
/**
 * @param {string} s
 * @return {string}
 */
var reverseVowels = function (s) {
  const origin = "aeiouAEIOU";
  let i = 0;
  let j = s.length - 1;
  const sArr = s.split("");
  while (i < j) {
    if (origin.includes(sArr[i]) && origin.includes(sArr[j])) {
      [sArr[i], sArr[j]] = [sArr[j], sArr[i]];
      i++;
      j--;
    }
    if (!origin.includes(sArr[i])) {
      i++;
    }
    if (!origin.includes(sArr[j])) {
      j--;
    }
  }
  return sArr.join("");
};
```
