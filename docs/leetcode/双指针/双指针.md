# 双指针

## 双指针种类

1. 快慢指针
2. 对撞指针
3. 滑动窗口

## 简介

二分查找也称**折半查找（Binary Search）**，它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列

::: tip 快慢指针

1. 折半查找要求线性表必须采用**顺序存储结构**
2. 而且表中元素按关键字**有序排列**

:::

::: tip 对撞指针

* 顺序结构

:::


::: tip 滑动窗口

* 顺序结构

:::

## 思路分析

* 首先确定该数组的中间的下标mid = (left + right) / 2
* 然后让需要查找的数 findVal 和 arr[mid] 比较

  * findVal > arr[mid] ,  说明你要查找的数在mid 的右边, 因此需要递归的向右查找
  * findVal < arr[mid], 说明你要查找的数在mid 的左边, 因此需要递归的向左查找
  * findVal == arr[mid] 说明找到，就返回
* 什么时候我们需要结束递归.

## 公式

### 对撞指针公式

```js
const formula = (s) => {
  // 缓存对撞指针长度
  const len = s.length;
  // 左指针
  let i = 0;
  // 右指针
  let j = len - 1;
  while (i < j) {
    if (/符合条件/) {
      [s[i], s[j]] = [s[j], s[i]];
      i++;
      j--;
    }
    if (/其他条件/) {
      i++;
    }
    if (/其他条件/) {
      j--;
    }
  }
  return s;
};

```

### 滑动窗口公式

```js
const formula = (s) => {
  // 缓存对撞指针长度
  const len = s.length;
  // 左指针
  let i = 0;
  // 右指针
  let j = len - 1;
  while (i < j) {
    if (/符合条件/) {
      [s[i], s[j]] = [s[j], s[i]];
      i++;
      j--;
    }
    if (/其他条件/) {
      i++;
    }
    if (/其他条件/) {
      j--;
    }
  }
  return s;
};
```

## 题目练习

### 对撞题目练习

#### [验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

> 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

::: tip 说明

本题中，我们将空字符串定义为有效的回文串。

:::

**示例 1:**

```js
输入: "A man, a plan, a canal: Panama"
输出: true
```

**示例 2:**

```js
输入: "race a car"
输出: false
```

**题解:**

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
  const replaces = s.replace(/[\W_]*/g, "").toLowerCase();
  if (!replaces.length) {
    return true;
  }
  let i = 0;
  let j = replaces.length - 1;
  while (i < j && replaces[i] === replaces[j]) {
    i++;
    j--;
  }
  return i >= j;
};
```

#### [反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)

编写一个函数，以字符串作为输入，反转该字符串中的元音字母。

**示例 1：**

```js
输入："hello"
输出："holle"
```

**示例 2：**

```js
输入："leetcode"
输出："leotcede"
```

**提示：**

* 元音字母不包含字母 "y" 。

```js
/**
 * @param {string} s
 * @return {string}
 */
var reverseVowels = function (s) {
  const origin = "aeiouAEIOU";
  let i = 0;
  let j = s.length - 1;
  const sArr = s.split("");
  while (i < j) {
    if (origin.includes(sArr[i]) && origin.includes(sArr[j])) {
      [sArr[i], sArr[j]] = [sArr[j], sArr[i]];
      i++;
      j--;
    }
    if (!origin.includes(sArr[i])) {
      i++;
    }
    if (!origin.includes(sArr[j])) {
      j--;
    }
  }
  return sArr.join("");
};
```

#### [盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器。

**示例 1：**

```js
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**

```js
输入：height = [1,1]
输出：1
```

::: tip  思路

根据面积计算规则，面积是由两个柱子的距离和柱子最低高度决定的。

所以，一开始前后指针指向第一根柱子和最后一根柱子，计算这两根柱子的面积，此时他们距离是最大的。

由于高度收到最低的限制，所以前后指针中高度最低的往中间移动，知道找到比它高的柱子（因为距离在减少，所以只有高度增大才有机会比之前的大），再重新计算面积，并和前面的比较，取最大值。

知道前后指针重合

:::

双指针题解:

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  if (!height || !height.length) return 0;
  let max = 0,
    l = 0,
    r = height.length - 1,
    curArea;
  while (l < r) {
    curArea = (r - l) * Math.min(height[l], height[r]);
    height[l] < height[r] ? l++ : r--;
    max = Math.max(curArea, max);
  }
  return max;
};
```

### 滑动窗口题目练习

---


### [长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

**示例：**

```js
输入：s = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

::: tip 思路:

1. 连续子数组可以表示为 [i,j][i,j]：从第 i 项到第 j 项。
2. 当 [i,j][i,j] 子数组和 >= s，如果此时扩张窗口，条件依然满足，但背离“最小长度”的要求。
   1. 所以选择收缩窗口，i 右移，直到条件不再满足（这里是一个循环），这是在优化可行解，并让窗口长度挑战最小纪录。
3. 当窗口的和 < s，此时应该扩张窗口，j 右移，直到条件重新满足。

:::

::: tip 总结:

* 扩张窗口：为了找到一个可行解，找到了就不再扩张
* 收缩窗口：在长度上优化该可行解，直到条件被破坏
* 寻找下一个可行解，然后再优化到不能优化……

:::

```js
const minSubArrayLen = (s, nums) => {
  let minLen = Infinity;
  let i = 0;
  let j = 0;
  let sum = 0;
  while (j < nums.length) {   // 主旋律是扩张，找可行解
    sum += nums[j];
    while (sum >= s) {        // 间歇性收缩，优化可行解
      minLen = Math.min(minLen, j - i + 1);
      sum -= nums[i];
      i++;
    }
    j++;
  }
  return minLen === Infinity ? 0 : minLen; // 从未找到可行解，返回0
};
```
