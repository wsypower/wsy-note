# 双指针

## 双指针种类


| 双指针种类 | 对应题 | 关键词 |
| - | - | - |
| 快慢指针 |   |   |
| 对撞指针 | 对称<br /> |   |

## 关键词

* 对称

## 简介

二分查找也称**折半查找（Binary Search）**，它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列

::: tip 注意

1. 折半查找要求线性表必须采用**顺序存储结构**
2. 而且表中元素按关键字**有序排列**

:::

::: tip 关键词

* 顺序结构

:::

## 思路分析

* 首先确定该数组的中间的下标mid = (left + right) / 2
* 然后让需要查找的数 findVal 和 arr[mid] 比较

  * findVal > arr[mid] ,  说明你要查找的数在mid 的右边, 因此需要递归的向右查找
  * findVal < arr[mid], 说明你要查找的数在mid 的左边, 因此需要递归的向左查找
  * findVal == arr[mid] 说明找到，就返回
* 什么时候我们需要结束递归.

## 公式

```js
const formula = (s) => {
  // 缓存对撞指针长度
  const len = s.length;
  // 左指针
  let i = 0;
  // 右指针
  let j = len - 1;
  while (i < j) {
    if (/符合条件/) {
      [s[i], s[j]] = [s[j], s[i]];
      i++;
      j--;
    }
    if (/其他条件/) {
      i++;
    }
    if (/其他条件/) {
      j--;
    }
  }
  return s;
};

```

### 对撞题目练习

---

#### [验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

> 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

::: tip 说明

本题中，我们将空字符串定义为有效的回文串。

:::

**示例 1:**

```js
输入: "A man, a plan, a canal: Panama"
输出: true
```

**示例 2:**

```js
输入: "race a car"
输出: false
```

**题解:**

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
  const replaces = s.replace(/[\W_]*/g, "").toLowerCase();
  if (!replaces.length) {
    return true;
  }
  let i = 0;
  let j = replaces.length - 1;
  while (i < j && replaces[i] === replaces[j]) {
    i++;
    j--;
  }
  return i >= j;
};
```

#### [反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)

编写一个函数，以字符串作为输入，反转该字符串中的元音字母。

**示例 1：**

```js
输入："hello"
输出："holle"
```

**示例 2：**

```js
输入："leetcode"
输出："leotcede"
```

**提示：**

* 元音字母不包含字母 "y" 。

```js
/**
 * @param {string} s
 * @return {string}
 */
var reverseVowels = function (s) {
  const origin = "aeiouAEIOU";
  let i = 0;
  let j = s.length - 1;
  const sArr = s.split("");
  while (i < j) {
    if (origin.includes(sArr[i]) && origin.includes(sArr[j])) {
      [sArr[i], sArr[j]] = [sArr[j], sArr[i]];
      i++;
      j--;
    }
    if (!origin.includes(sArr[i])) {
      i++;
    }
    if (!origin.includes(sArr[j])) {
      j--;
    }
  }
  return sArr.join("");
};
```



#### [盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器。

**示例 1：**

```js
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**

```js
输入：height = [1,1]
输出：1
```

::: tip  思路

根据面积计算规则，面积是由两个柱子的距离和柱子最低高度决定的。

所以，一开始前后指针指向第一根柱子和最后一根柱子，计算这两根柱子的面积，此时他们距离是最大的。

由于高度收到最低的限制，所以前后指针中高度最低的往中间移动，知道找到比它高的柱子（因为距离在减少，所以只有高度增大才有机会比之前的大），再重新计算面积，并和前面的比较，取最大值。

知道前后指针重合

:::

双指针题解:

```js
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  if (!height || !height.length) return 0;
  let max = 0,
    l = 0,
    r = height.length - 1,
    curArea;
  while (l < r) {
    curArea = (r - l) * Math.min(height[l], height[r]);
    height[l] < height[r] ? l++ : r--;
    max = Math.max(curArea, max);
  }
  return max;
};
```
